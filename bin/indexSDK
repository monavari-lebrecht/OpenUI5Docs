#!/usr/bin/env node

var fs = require('fs');
var mkdirp = require('mkdirp');
var path = require('path');
var log = require('verbalize');
var _ = require('lodash');
var ncp = require('ncp').ncp;
var sqlite3 = require('sqlite3').verbose();
var Crawler = require("crawler").Crawler;
var argv = require('minimist')(process.argv.slice(2));

/**
 * Everything in the file should be customized
 */


	// Verbalize `runner`
log.runner = 'open-ui5-docs';

// Use `-n` or `--name` to specify the text to append
var name = argv._[0] || argv.n || argv.name;

// Use `-n` or `--name` to specify the text to append
var jsdocs = argv._[1] || argv.d || argv.jsdocs;

var docsetPath = path.resolve() + '/' + name + '.docset/';
var targetDocumentationDirectory = docsetPath + 'Contents/Resources/Documents/';

/**
 * populates database with data from docset
 */
function populateDatabase() {
	// create sqlite database
	var sqliteFile = docsetPath + 'Contents/Resources/docSet.dsidx';
	var database = new sqlite3.Database(sqliteFile);

	database.serialize(function () {
		// create tables
		database.run("CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT)");
		database.run("CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path)");
		var stmt = database.prepare("INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (?, ?, ?)");

		// copy all resource files files to dashdocset
		var resources = [
			{
				'path'       : '/resources/sap/ui/thirdparty/jquery/',
				'filename'   : 'jquery-1.7.1.js'
			},
			{
				'path'       : '/js/',
				'filename'   : 'utils.js'
			},
			{
				'path'       : '/theme/',
				'filename'   : 'default.css'
			},
			{
				'path'       : '/docs/api/',
				'filename'   : 'default.css'
			}
		];

		copyResources(resources);

		// crawl each file and insert its contents to index
		var crawler = new Crawler({
			"maxConnections": 10
		});

		// get all files in to index
		fs.readdir(targetDocumentationDirectory + 'docs/api/symbols', function (err, files) {
			files.forEach(function (file) {
				var filePath = targetDocumentationDirectory + 'docs/api/symbols/' + file;

				if (file == '.DS_Store') {
					return;
				}

				processDocSetFile(filePath, resources);

				fs.lstat(filePath, function (err, stats) {
					if (stats.isFile()) {
						fs.readFile(filePath, function (err, data) {
							crawler.queue([
								{
									'html': data,
									// This will be called for each crawled page
									"callback"      : function (error, result, $) {
										if (error == null) {
											// insert class to index
											var classInformation = $('.classTitle').text().trim().match(/(Namespace|Class|Static Class|Interface)(.*)/);
											if(typeof classInformation != 'undefined') {
												var classTitle = classInformation[2].trim();
												var type = classInformation[1].trim();
												switch (type) {
													case 'Static Class':
													case 'Class':
														type = 'Class';
														break;
												}
												stmt.run(classTitle, type, 'docs/api/symbols/' + file);
												console.log('add ' + type + ' to db index: ' + classTitle);

												// insert methods of class to index
												$('.summary .classMethod b a').each(function () {
													"use strict";
													// documentation is a bit inconstistent.. :( sometimes the total name is used, and sometimes not...
													// so we check if a dot is present and if not we add the namespace
													var title = $(this).text();
													if(title.search(/\./g) === -1) {
														title = classTitle + '.' + $(this).text();
													}
													stmt.run(title, 'Method', 'docs/api/symbols/' + $(this).attr('href'));
													console.log('add ' + 'Method' + ' to db index: ' + title);
												});
											}
										}
									}
								}
							]);
						});
					}
				});
			});
		});
		// when everything is parsed... write to db
		process.on('exit', function (code) {
			console.log('write to db');
			stmt.finalize();

			database.close();
		});
	});
}

function copyResources(resources) {
	"use strict";
	resources.forEach(function (resource) {
		mkdirp(targetDocumentationDirectory + resource.path, function () {
			"use strict";
			var readFrom = jsdocs + resource.path + resource.filename;
			fs.readFile(readFrom, 'utf8', function (err, data) {
				if (err) {
					return console.log(err);
				}

				fs.writeFile(targetDocumentationDirectory + resource.path + resource.filename, data, 'utf8', function (err) {
					if (err) {
						return console.log(err);
					}
				});

				console.log('resources copied');
			});
		});
	});
}

/**
 * processes docset file by copying resources and rewriting resources in file
 *
 * @param {String} filePath
 * @param {{}[]} resources
 */
function processDocSetFile(filePath, resources) {
	// rewrite resource paths on resource loading
	fs.readFile(filePath, 'utf8', function (err, data) {
		if (err) {
			return console.log(err);
		}

		for (resource in resources) {
			var result = data.replace('/' + resources[resource].rewriteFrom + '/g', resources[resource].toPath);
		}

		fs.writeFile(filePath, result, 'utf8', function (err) {
			if (err) {
				return console.log(err);
			}
		});
	});
}
/**
 * Application
 */

	// create filesystem for dash docset
mkdirp(targetDocumentationDirectory + 'docs/api/symbols', function () {
	console.log('Docset scaffold created!')
	// copy all jsdoc files to dashdocset
	ncp(jsdocs + '/docs/api/symbols', targetDocumentationDirectory + 'docs/api/symbols', function (err) {
		if (err) {
			return console.error(err);
		}
		console.log('Documentation copied!');

		populateDatabase();
	});

	// create info.plist file
	fs.readFile(__dirname + '/../templates/Info.plist', 'utf-8', function (err, data) {
		var infoPlistTemplated = _.template(data, {
			'bundleName': name
		});
		fs.writeFileSync(docsetPath + 'Contents/Info.plist', infoPlistTemplated);
	});
});
